


<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="description" content="iOS Libs 与 Frameworks 的理解和使用">
    <meta name="keywords" content="cocoapods,lib,framework,">
    <link rel="apple-touch-icon" href="/img/default_logo.png">
    <link href="//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <link href="//cdn.bootcss.com/highlight.js/9.10.0/styles/atom-one-light.min.css" rel="stylesheet">
    <title>iOS Libs 与 Frameworks 的理解和使用 - Eleme Mobilists</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/eleme-theme.css">
    
  
</head>
<body>

<div class="container-fluid eleme-wrapper">
    <nav class="navbar navbar-default eleme-navbar">
        <div class="container-fluid">
            <div class="navbar-header">
                <a class="navbar-brand" href="/">
                    <img alt="eleme" src="/img/eleme-logo.png" style="height: 20px">
                </a>
                <button class="navbar-toggle" data-toggle="collapse" href="#eleme-navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>

            <div class="collapse navbar-collapse" id="eleme-navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li><a href="/archives">归档</a></li>
                
                <li><a href="/about">关于</a></li>
                
                <li><a href="/friend">友链</a></li>
                
                <li><a href="/atom.xml">订阅</a></li>
                
            </ul>
            </div>
        </div>

    </nav>

    <div class="eleme-body">
        <div id="content-inner">
            <article id="post" class="container">
    <h1 class="post-title">iOS Libs 与 Frameworks 的理解和使用</h1>
    <p class="post-meta">
        
        <span class="release">发表于
            <time datetime="2017-02-28T05:31:03.000Z">
            2017-02-28
            </time>
        </span>
        
        
        <span>&nbsp;分类: <a href="/categories/iOS/">iOS</a></span>
        
        
        <span class="author">&nbsp;authored by <a href="/author/axl411">axl411</a></span>
        
    </p>
    <div class="post-wrapper">
        <p>本文将从两个角度——理论与实践，来介绍 iOS 开发中接触到的动态库、静态库、framework。理论部分会以简单的例子来建立对概念的理解；实践部分则是使用 cocoapods 的一些技巧。</p>
<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><p>首先我们熟悉一下以下名词概念：</p>
<ul>
<li><p>代码（code）：不止是指源代码（source code）形式的代码，也指代编译后产生的二进制代码。</p>
</li>
<li><p>Mach-O：操作系统能够使用的二进制文件格式，很多种类的文件都是 Mach-O 文件，包括动态库、静态库、可执行文件，都是 Mach-O 文件。本文将替换使用多种代称，比如 <code>object file</code>、<code>对象文件</code>，都是指同一个概念。</p>
</li>
<li><p>动态库、 dynamic linked library、dynamic library、shared library、embedded shared library 这些名词都是指动态库。</p>
</li>
</ul>
<h1 id="理解-Libs-与-Frameworks"><a href="#理解-Libs-与-Frameworks" class="headerlink" title="理解 Libs 与 Frameworks"></a>理解 Libs 与 Frameworks</h1><p>Libs（库），或是 Frameworks，无论静态还是动态，都是一种依赖管理的形式，其最终目的都是将程序依赖的<code>代码</code>载入到程序所在进程的地址空间中，从而让我们的程序能够使用它们。静态库、动态库只是用了不同的机制来实现这个目的。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>我们直接以一个简单的例子讲述如何创建静态库并使用它，从而对静态库建立一个简单的概念。</p>
<h3 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h3><p>有如下两个简单的源代码 <code>bar.h</code> 和 <code>bar.c</code>。<code>bar.c</code> 中声明了 <code>fizz</code> 函数，使用 <code>CoreFoundation</code> 的方法打印一个字符串 <code>buzz</code>，<code>bar.h</code> 将 <code>fizz</code> 函数暴露了出来：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// bar.h</span></div><div class="line"><span class="meta">#ifndef __foo__bar__</span></div><div class="line"><span class="meta">#define __foo__bar__</span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> fizz();</div><div class="line"></div><div class="line"><span class="meta">#endif /* defined(__foo__bar__) */</span></div><div class="line"></div><div class="line"><span class="comment">// bar.c</span></div><div class="line"><span class="meta">#include <span class="meta-string">"bar.h"</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> fizz() &#123;</div><div class="line">  <span class="built_in">CFShow</span>(<span class="built_in">CFSTR</span>(<span class="string">"buzz"</span>));</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>clang</code> 将 <code>bar.c</code> 编译为  <code>bar.o</code>。为了简化问题，我们只输出为 <code>x86_64</code> 处理器架构编译的结果。从 <code>file</code> 命令的输出可以看到，输出的 <code>bar.o</code> 是 <code>Mach-O</code> object file：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ clang -c bar.c -o bar.o -arch x86_64</div><div class="line">$ file bar.o</div><div class="line">bar.o: Mach-O 64-bit object x86_64</div></pre></td></tr></table></figure>
<p>使用 <code>libtool</code>，以 <code>bar.o</code> 为输入，输出一个名称为 <code>libfoo_static.a</code> 的静态库。从 <code>file</code> 的输出可以看到，静态库的文件类型是 <code>current ar archive random library</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ libtool -static bar.o -o libfoo_static.a</div><div class="line">$ file libfoo_static.a</div><div class="line">libfoo_static.a: current ar archive random library</div></pre></td></tr></table></figure>
<h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><p>有如下简单的 <code>main.c</code> 源代码，通过 <code>bar.h</code> 调用了 <code>fizz</code> 函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main.c</span></div><div class="line"><span class="meta">#include <span class="meta-string">"bar.h"</span></span></div><div class="line"><span class="keyword">int</span> main() &#123;</div><div class="line">  <span class="keyword">return</span> fizz();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和制作静态库一样，用 <code>clang</code> 将 <code>main.c</code> 编译为 <code>main.o</code>。<code>main.o</code> 和 <code>bar.o</code> 的类型一样，都是 object file：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ clang -c main.c -o main.o -arch x86_64</div><div class="line">$ file main.o</div><div class="line">main.o: Mach-O 64-bit object x86_64</div></pre></td></tr></table></figure>
<p>用 <code>ld</code>（linker／链接器）来输出一个名为 <code>test_static</code> 的可执行文件。<code>ld</code> 接收的输入有：<code>main.o</code>、<code>CoreFoundation</code> framework、额外指定了当前文件夹为 library search path（<code>-L.</code>）、<code>libfoo_static</code>（<code>-lfoo_static</code>，正是因为额外指定了当前文件夹为 library search path 才能够找到它）、为简化问题只对 <code>x86_64</code> 架构编译（-lSystem 表示 libsystem，可以忽略，不影响对概念的理解）。通过 <code>file</code> 的输出可以看到 <code>test_static</code> 可执行文件也是一种 <code>Mach-O</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ld main.o -framework CoreFoundation <span class="_">-l</span>System -L. -lfoo_static -o test_static -arch x86_64</div><div class="line">$ file test_static</div><div class="line">test_static: Mach-O 64-bit executable x86_64</div></pre></td></tr></table></figure>
<p>执行 <code>test_static</code>，功能正常，输出了 <code>buzz</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ./test_static</div><div class="line">buzz</div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用 <code>nm</code> 查看 <code>test_static</code> 可执行文件的符号表（symbol table），留意如下信息：</p>
<ul>
<li><p><code>_CFShow</code>、<code>___CFConstantStringClassReference</code> 是来自 <code>CoreFoundation</code> framework 的 symbol，在这里还未被 resolve（即还没有指令所在的地址），这是因为 <code>CoreFoundation</code> framework 是动态链接的，两个 symbol 代表的指令的地址并不会在编译时被 resolve。（后面讲动态链接会介绍动态链接的 symbol 是如何 resolve 的）</p>
</li>
<li><p><code>_fizz</code> symbol 是来自静态库 <code>libfoo_static</code> 的，在这里已经被 resolve 了，即具体的指令已经存在于 <code>test_static</code> 的二进制中了。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nm test_static</div><div class="line">                 U _CFShow</div><div class="line">                 U ___CFConstantStringClassReference</div><div class="line">0000000100000000 T __mh_execute_header</div><div class="line">0000000100000f70 T _fizz</div><div class="line">0000000100000f50 T _main</div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>
<p>查看 <code>libfoo_static</code> 以及 <code>bar.o</code> 的符号表，我们发现：</p>
<ul>
<li><p><code>libfoo_static</code> 和 <code>bar.o</code> 的符号表内容是完全一样的。</p>
</li>
<li><p>从 <code>libfoo_static.a(bar.o):</code> 看出，静态库会把它包含的所有 object file 的符号表分别输出，静态库只是简单的 object file 的集合，这里 <code>libfoo_static</code> 只包含了一个 <code>bar.o</code>。</p>
</li>
<li><p>一样有 unresolved 的 <code>CoreFoundation</code> 的 symbol。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nm libfoo_static.a</div><div class="line">libfoo_static.a(bar.o):</div><div class="line">                 U _CFShow</div><div class="line">                 U ___CFConstantStringClassReference</div><div class="line">0000000000000000 T _fizz</div><div class="line"></div><div class="line">$ nm bar.o</div><div class="line">                 U _CFShow</div><div class="line">                 U ___CFConstantStringClassReference</div><div class="line">0000000000000000 T _fizz</div></pre></td></tr></table></figure>
<p>用 <code>otool</code> 查看 <code>libfoo_static</code> 对 shared library 的依赖，没有看到任何依赖信息，因此指定依赖的责任自然就到了静态库的使用方。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ otool -L libfoo_static.a</div><div class="line">Archive : libfoo_static.a</div><div class="line">libfoo_static.a(bar.o):</div></pre></td></tr></table></figure>
<p>一个典型的静态库的例子是微信 SDK。它的接入文档会提到：</p>
<blockquote>
<p>SDK文件包括 libWeChatSDK.a，WXApi.h，WXApiObject.h 三个</p>
</blockquote>
<p>并且：</p>
<blockquote>
<p>开发者需要在工程中链接上:SystemConfiguration.framework, libz.dylib, libsqlite3.0.dylib, libc++.dylib, Security.framework, CoreTelephony.framework, CFNetwork.framework</p>
</blockquote>
<p>这和我们看到的例子中自己制作的静态库概念是一样的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过具体的例子，我们可以理解关于静态库的如下概念：</p>
<ul>
<li><p>静态库就是 object file 的集合。</p>
</li>
<li><p>因此，在使用静态库的时候需要自行指定静态库的任何依赖。</p>
</li>
<li><p>静态链接会直接将静态库中的 object file 加到 target（比如 <code>test_static</code> 可执行文件） 中去。</p>
</li>
</ul>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>动态库和静态库的最大区别是，动态库的代码不会直接加入到目标程序中，而是在启动时由 dynamic link editor <code>dyld</code> 加载到 app 的内存地址空间；另外，动态库包含自己的依赖信息。下面我们依然通过实例来理解这个概念。</p>
<h3 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h3><p>复用前面制作静态库时编译出的 <code>bar.o</code>，依然使用 <code>libtool</code>，生成名为 <code>libfoo_dynamic.dylib</code> 的动态库。注意这里需要指定 <code>CoreFoundation</code> framework（可以忽略 -lSystem，不影响对概念的理解）。生成的 <code>libfoo_dynamic</code> 的文件类型是动态库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ libtool -dynamic bar.o -o libfoo_dynamic.dylib -framework CoreFoundation <span class="_">-l</span>System</div><div class="line">$ file libfoo_dynamic.dylib</div><div class="line">libfoo_dynamic.dylib: Mach-O 64-bit dynamically linked shared library x86_64</div></pre></td></tr></table></figure>
<p>使用 linker <code>ld</code> 来输出一个可执行文件 <code>test_dynamic</code>。这次的输入是同样复用前面编译出的 <code>main.o</code>、<code>foo_dynamic</code> 动态库（忽略 <code>-lSystem</code>），并指定当前文件夹 <code>.</code>（也就是 <code>foo_dynamic</code> 动态库所在的文件夹） 为 library search path。<code>test_dynamic</code> 同样是 <code>Mach-O</code> 可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ld main.o <span class="_">-l</span>System -L. -lfoo_dynamic -o test_dynamic -arch x86_64</div><div class="line">$ file test_dynamic</div><div class="line">test_dynamic: Mach-O 64-bit executable x86_64</div></pre></td></tr></table></figure>
<p>执行 <code>test_dynamic</code>，同样能够输出正确的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ./test_dynamic</div><div class="line">buzz</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>用 <code>nm</code> 查看 <code>test_dynamic</code> 可执行文件的 symbol table，留意如下信息：</p>
<ul>
<li><p>来自 <code>CoreFoundation</code> framework 的 <code>_CFShow</code>、<code>___CFConstantStringClassReference</code> symbol 并没有存在于 <code>test_dynamic</code> 的符号表中。<code>_fizz</code> 符号只是个 reference，并没有被 resolve。</p>
</li>
<li><p>来自动态库 <code>libfoo_dynamic</code> 的 <code>_fizz</code> symbol 在这里并没有被 resolve。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nm test_dynamic</div><div class="line">0000000100000000 T __mh_execute_header</div><div class="line">                 U _fizz</div><div class="line">0000000100000f70 T _main</div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>
<p>查看 <code>libfoo_dynamic</code> 以及 <code>bar.o</code> 的符号表，我们发现：</p>
<ul>
<li><code>libfoo_dynamic</code> 和 <code>bar.o</code> 的 symbol table 内容并不是完全一样的，<code>_fizz</code> symbol 的地址在两者的 symbol table 中是不同的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nm libfoo_dynamic.dylib</div><div class="line">                 U _CFShow</div><div class="line">                 U ___CFConstantStringClassReference</div><div class="line">0000000000000f70 T _fizz</div><div class="line">                 U dyld_stub_binder</div><div class="line"></div><div class="line">$ nm bar.o</div><div class="line">                 U _CFShow</div><div class="line">                 U ___CFConstantStringClassReference</div><div class="line">0000000000000000 T _fizz</div></pre></td></tr></table></figure>
<p>用 <code>otool</code> 查看 <code>libfoo_dynamic</code> 的依赖信息，可以看到 <code>CoreFoundation</code> 是在里面的（同样，忽略 <code>libSystem</code>），因此使用方就不需要指定这个依赖了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ otool -L libfoo_dynamic.dylib</div><div class="line">libfoo_dynamic.dylib:</div><div class="line">	libfoo_dynamic.dylib (compatibility version 0.0.0, current version 0.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div></pre></td></tr></table></figure>
<p>经过具体的例子，我们可以理解关于动态库的如下概念：</p>
<ul>
<li><p>动态库包含了自己的依赖信息，因此，在使用动态库的时候直接使用动态库就可以。</p>
</li>
<li><p>动态链接并不会直接将动态库中的 object file 加到 target（比如 <code>test_dynamic</code> 可执行文件） 中去。</p>
</li>
</ul>
<h3 id="程序是如何使用动态库的"><a href="#程序是如何使用动态库的" class="headerlink" title="程序是如何使用动态库的"></a>程序是如何使用动态库的</h3><p>当执行程序时，例如执行 <code>./test_dynamic</code> 时，在其 <code>main</code> 函数被调用前，Kernel 除了会把 <code>test_dynamic</code> 载入到为其分配的内存空间外，还会载入 <code>dyld</code> linker，然后 <code>dyld</code> 会根据 <code>test_dynamic</code> 的依赖信息，将它依赖的 shared library（也就是 <code>libfoo_dynamic</code>）以及这些 shared library 的依赖（也就是 <code>CoreFoundation</code>）同样载入到内存地址空间。<code>test_dynamic</code> 中未 resolve 的 <code>_fizz</code> symbol 会在这时被 resolve。</p>
<p>这些 shared library 实际上在设备的物理内存中只存在一份，通过一个 mapping 的机制让它们能同时存在于多个应用的内存地址空间中。</p>
<p>另外，既然在物理内存中只存在一份，那多个应用使用的同一个 shared library 中的同一个变量是如何有对于该应用而言独有的 value 的呢？知道 Copy on Write 机制，字面意思就是在写操作时就 copy 一份这个概念就行了。</p>
<p>具体的细节可以参考<a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">这集WWDC</a>。</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>在理解了动态库、静态库的基础上，framework 只是一个后缀为 <code>.framework</code> 的文件夹，包含了额外的资源，例如头文件、图片、文档、多语言支持资源、nib 等等。虽然 Framework  还有版本的概念，可以同时包含多个版本的 framework 在同一个 <code>.framework</code> 内，但对于 iOS 来说这不重要，因为我们的 Framework 是随 app 的 bundle 一起发布的，不存在被多方使用的问题。动态库在 app bundle 内的位置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">MyApp.app</div><div class="line">├── Frameworks</div><div class="line">│   └── MyDylib.dylib</div><div class="line">│   └── MyFramework.framework</div></pre></td></tr></table></figure>
<h1 id="（用-cocoapods）使用-Libs-与-Frameworks"><a href="#（用-cocoapods）使用-Libs-与-Frameworks" class="headerlink" title="（用 cocoapods）使用 Libs 与 Frameworks"></a>（用 cocoapods）使用 Libs 与 Frameworks</h1><blockquote>
<p>将 libWeChatSDK.a，WXApi.h，WXApiObject.h 这三个拖到主工程</p>
<p>开发者需要在工程中链接上:a.framework, b.dylib, c.dylib, d.dylib, e.framework, f.framework, g.framework</p>
<p>将 a.png，b.png，c.js 拖到主工程</p>
</blockquote>
<p>手动接入某个库或 Framework 往往需要做上面这些手动的事情，时间一长、接入的多了，非常不利于项目的维护。</p>
<p><a href="https://cocoapods.org/" target="_blank" rel="external"><code>cocoapods</code></a> 提供了非常好的依赖管理机制，并且可以用来对我们要使用的库、framework 进行封装，方便管理维护，不管是静态库、动态库还是 framework，只要填写一份统一的 <code>podspec</code>，就能完成对依赖的封装。如下所示，封装一个依赖的 <code>podspec</code> 通常涉及到填写这些属性：</p>
<ul>
<li><code>vendored_frameworks</code>：要封装的 framework 的路径</li>
<li><code>vendored_libraries</code>：要封装的 lib 的路径</li>
<li><code>source_files</code>：这里只需要填写想要暴露的头文件的路径</li>
<li><code>libraries</code>：要封装的库所需要的依赖库</li>
<li><code>frameworks</code>：要封装的库所依赖的 framework</li>
<li><code>weak_framework</code>：要封装的库所依赖的 weak link 的 framework，例如 <code>UserNotifications</code> framework 是一个 iOS 10 才有的 framework，通过 weak linking + runtime availability check，可以在低于 iOS 10 的平台上安全地跑起来</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">spec.vendored_frameworks = <span class="string">'a.framework'</span>, <span class="string">'b.framework'</span></div><div class="line">spec.vendored_libraries = <span class="string">'liba.a'</span>, <span class="string">'libb.a'</span></div><div class="line">spec.source_files = ‘Headers/Public/*.h<span class="string">'</span></div><div class="line">spec.libraries = 'xml2<span class="string">', '</span>z<span class="string">'</span></div><div class="line">spec.frameworks = 'QuartzCore<span class="string">', ‘CoreData'</span></div><div class="line">spec.weak_framework = ‘UserNotifications’</div></pre></td></tr></table></figure>
<h2 id="静态库转动态库"><a href="#静态库转动态库" class="headerlink" title="静态库转动态库"></a>静态库转动态库</h2><p>一般不推荐这么做，不过把静态库转动态库也是可行的。</p>
<p>操作的方法是：</p>
<ul>
<li>确保该静态库包含全部需要的架构。</li>
<li>用 Xcode 创建一个 Cocoa Touch Framework 的 project，用来封装静态库。</li>
<li>把静态库、静态库的头文件正常手动加入到项目中。</li>
<li>在 Build Settings 中的 Other Linker Flags 中加入 <code>-all_load</code> flag，从而在 link 时把所有静态库中的代码加载进来。</li>
<li>在 Build Settings 中的 Framework Search Paths 以及 Library Search Paths 中添加静态库所在的路径，从而在 compile 时能找到该静态库。</li>
<li>在 Build Phase 中的 Link Binary With Libraries 区域加入添加的静态库。</li>
<li>在 Build Phase 中的 Headers 区域把要暴露的头文件移到 Public。</li>
<li>根据静态库的接入文档，在工程中链接上需要的其他库、framework。</li>
<li>到这一步应该编译通过了。</li>
<li>目前的 Xcode 只会输出 only 模拟器 or only device 架构的动态库，因此为了生成一个可同时被模拟器以及真机使用的动态库，需要输出两次，并用 <code>lipo</code> 工具把架构合并。</li>
<li>蛋疼的是，当使用这个动态库的工程打包时，又需要用 <code>lipo</code> 工具把不需要的架构去掉（也就是为真机打包时，要去掉模拟器的架构）。</li>
</ul>
<p>正是因为需要做这么多额外的工作，因此不推荐这么做。不过，把生成的动态库用 cocoapods 封装的话，cocoapods 在安装时会生成自动去除不需要架构的 build phase。</p>
<p>这么做有一个风险就是，由于改变了链接库的方式，最后库的资源在 iOS app 中的路径也会改变，如果库的开发者在编写库时取资源的姿势做了简单的假设的话（假设资源肯定在 app 的 main bundle 中），就会取不到资源了。下一章将详细介绍一下在库中取资源的姿势。</p>
<h2 id="资源的读取"><a href="#资源的读取" class="headerlink" title="资源的读取"></a>资源的读取</h2><p>在 pod 中取资源不能简单假设资源所在的位置，否则会取不到资源。我们直接通过例子来看这个问题。假设有下面这样一个 pod：</p>
<ul>
<li>名字叫 <code>MyPod</code></li>
<li>通过 <code>resources</code> 来指定资源，这是不推荐的做法</li>
<li>通过 <code>resource_bundles</code> 来指定资源，这是推荐的做法</li>
<li>包含的资源是名叫 <code>img.png</code> 的图片</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">s.name = ‘MyPod’</div><div class="line"></div><div class="line"><span class="comment"># 不推荐的做法</span></div><div class="line">s.resources = “<span class="comment">#&#123;PATH_TO_RESOURCE&#125;”</span></div><div class="line"></div><div class="line">s.resource_bundles = &#123; <span class="string">'MyPod'</span> =&gt; <span class="string">"<span class="subst">#&#123;PATH_TO_RESOURCE&#125;</span>"</span> &#125;</div></pre></td></tr></table></figure>
<p>然后，我们有一个 iOS app 叫做 <code>MyApp</code>，用 3 种姿势来使用这个 pod：</p>
<ul>
<li>case 1：在 <code>Podfile</code> 里用 <code>use_frameworks!</code> 来安装 pod（pod 会被编译为动态库）</li>
<li>case 2：在 <code>Podfile</code> 里不用 <code>use_frameworks!</code> 来安装 pod（pod 会被编译为静态库）</li>
<li>case 3：在 <code>MyApp</code> 工程里手动建一个名叫 <code>MyHandMadeFramework</code> 的 Cocoa Touch Framework，并通过 pod 把 <code>MyPod</code> 安装在 <code>MyHandMadeFramework</code> 的 target 上，然后 <code>MyApp</code> 手动引入 <code>MyHandMadeFramework</code> 来使用。这种 case 虽然绕了点，但也是完全合理的一种使用姿势，并且资源在这种 case 下所在的位置是比较特别的。</li>
</ul>
<h3 id="用-resources-指定资源的情况"><a href="#用-resources-指定资源的情况" class="headerlink" title="用 resources 指定资源的情况"></a>用 <code>resources</code> 指定资源的情况</h3><p>最终 <code>img.png</code> 在3种情况下编译出来的 app 中的路径如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="comment">// "case 1"</span></div><div class="line">MyApp.app/Frameworks/MyPod.framework/<span class="selector-tag">img</span><span class="selector-class">.png</span></div><div class="line"><span class="comment">// "case 2"</span></div><div class="line">MyApp.app/<span class="selector-tag">img</span><span class="selector-class">.png</span></div><div class="line"><span class="comment">// "case 3"</span></div><div class="line">MyApp.app/Frameworks/MyHandMadeFramework.framework/<span class="selector-tag">img</span>.png</div></pre></td></tr></table></figure>
<p>因此，如果在取资源的时候简单地假设资源肯定在 main bundle，用如下姿势去取的话，肯定是不 work 的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"img"</span> ofType:@“png”];</div></pre></td></tr></table></figure>
<p>正确的做法是用 <code>bundleForClass</code> 取出 <code>MyPod</code> 的代码所在的 bundle:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSBundle</span> *bundleContainingPodsCode = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</div></pre></td></tr></table></figure>
<p><code>bundleContainingPodsCode</code> 的路径分别是：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><div class="line"><span class="comment">// "case 1"</span></div><div class="line">MyApp.<span class="keyword">app</span>/Frameworks/MyPod.framework/</div><div class="line"><span class="comment">// "case 2"</span></div><div class="line">MyApp.<span class="keyword">app</span>/</div><div class="line"><span class="comment">// "case 3"</span></div><div class="line">MyApp.<span class="keyword">app</span>/Frameworks/MyHandMadeFramework.framework/</div></pre></td></tr></table></figure>
<p>然后以这个 bundle 的相对路径去取资源就始终能取到正确的资源了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *imgPath = [bundleContainingPodsCode pathForResource:<span class="string">@"img"</span> ofType:@“png”];</div></pre></td></tr></table></figure>
<h3 id="用-resource-bundles-指定资源的情况"><a href="#用-resource-bundles-指定资源的情况" class="headerlink" title="用 resource_bundles 指定资源的情况"></a>用 <code>resource_bundles</code> 指定资源的情况</h3><p>最终 <code>img.png</code> 在3种情况下编译出来的 app 中的路径如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="comment">// "case 1"</span></div><div class="line">MyApp.app/Frameworks/MyPod.framework/MyPod.bundle/<span class="selector-tag">img</span><span class="selector-class">.png</span></div><div class="line"><span class="comment">// "case 2"</span></div><div class="line">MyApp.app/MyPod.bundle/<span class="selector-tag">img</span><span class="selector-class">.png</span></div><div class="line"><span class="comment">// "case 3"</span></div><div class="line">MyApp.app/Frameworks/MyHandMadeFramework.framework/MyPod.bundle/<span class="selector-tag">img</span>.png</div></pre></td></tr></table></figure>
<p>可以看到这种情况和 <code>resources</code> 的情况区别在于：<code>img.png</code> 被额外放在了名叫 <code>MyPod.bundle</code> 的 bundle 内。因此，取资源的姿势上要额外把这个 bundle 取出来，再用相对路径去取资源：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSBundle</span> *libBundle = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</div><div class="line"><span class="built_in">NSString</span> *resourceBundlePath = [[libBundle bundlePath] stringByAppendingPathComponent:<span class="string">@"MyPod.bundle"</span>];</div><div class="line"><span class="built_in">NSBundle</span> *resourceBundle = [<span class="built_in">NSBundle</span> bundleWithPath:resourceBundlePath]; <span class="comment">// 这里应该把 resourceBundle 缓存下来</span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *imgPath = [resourceBundle pathForResource:<span class="string">@"img"</span> ofType:@“png”];</div></pre></td></tr></table></figure>
<p>当然，如果你的 app 的 deployment target 为 iOS 8，那么可以直接用如下这个新的 api 来从 resource bundle 里取图片：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"img"</span> inBundle:resourceBundle compatibleWithTraitCollection:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<hr>
<p>全文完</p>

    </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'elememobileblog';
        var disqus_identifier = '2017/02/28/iOS-Libs-与-Frameworks-的理解和使用/';
        var disqus_title = 'iOS Libs 与 Frameworks 的理解和使用';
        var disqus_url = 'http://mobilists.eleme.io/2017/02/28/iOS-Libs-与-Frameworks-的理解和使用/';

        function run_disqus_script(disqus_script){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }

        run_disqus_script('count.js');
        
        run_disqus_script('embed.js');
        
    </script>

    <noscript>Please enable JavaScript to view the comments</noscript>

    
</article>



<nav class="pagination row">

    <div class="pagination-indicator col-xs-4">
        
        <a href="/2017/04/21/移动组博客的选型和构建/" class="prev-post">< 移动组博客的选型和构建</a>
        
    </div>
  <div class="pagination-number col-xs-4">
      
  </div>

 <div class="pagination-indicator col-xs-4">
     
     <a href="/2017/01/11/使用链式调用解决多可选参数接口设计问题/" class="next-post">使用链式调用解决多可选参数接口设计问题 ></a>
     
 </div>
</nav>



        </div>
    </div>

    <div class="eleme-footer">
        <div id="bottom-inner">
            <p class="eleme-copyright">&copy; copyright 2016-2017 by Eleme Mobilists</p>
            <p class="eleme-theme-copyright">eleme-mobile hexo theme by eleme ios team</a></p>
            <br>
        </div>
    </div>
    
    
    <script src="/js/eleme-theme.js"></script>
    
    
    <script src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script>
    <script src="//cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdn.bootcss.com/highlight.js/9.10.0/highlight.min.js"></script>
    <script>
      $(document).ready(function() {
        $('figure').each(function(i, block) {
          hljs.highlightBlock(block);
        });
      });
    </script>
</div>

</body>
</html>
